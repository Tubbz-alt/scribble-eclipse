/*
* generated by Xtext
*/
package org.scribble.editor.dsl.ui.labeling

import com.google.inject.Inject
import org.scribble.editor.dsl.scribbleDsl.Module
import org.scribble.editor.dsl.scribbleDsl.PayloadTypeDecl
import org.scribble.editor.dsl.scribbleDsl.GlobalProtocolDecl
import org.scribble.editor.dsl.scribbleDsl.LocalProtocolDecl
import org.scribble.editor.dsl.scribbleDsl.GlobalMessageTransfer
import org.scribble.editor.dsl.scribbleDsl.GlobalProtocolBlock
import org.scribble.editor.dsl.scribbleDsl.LocalProtocolBlock
import org.scribble.editor.dsl.scribbleDsl.GlobalDo
import org.scribble.editor.dsl.scribbleDsl.GlobalChoice
import org.scribble.editor.dsl.scribbleDsl.GlobalParallel
import org.scribble.editor.dsl.scribbleDsl.GlobalRecursion
import org.scribble.editor.dsl.scribbleDsl.GlobalContinue
import org.scribble.editor.dsl.scribbleDsl.LocalChoice
import org.scribble.editor.dsl.scribbleDsl.LocalParallel
import org.scribble.editor.dsl.scribbleDsl.LocalRecursion
import org.scribble.editor.dsl.scribbleDsl.LocalContinue
import org.scribble.editor.dsl.scribbleDsl.LocalDo
import org.scribble.editor.dsl.scribbleDsl.LocalSend
import org.scribble.editor.dsl.scribbleDsl.LocalReceive
import org.scribble.editor.dsl.scribbleDsl.GlobalInterruptible
import org.scribble.editor.dsl.scribbleDsl.GlobalInterrupt
import org.scribble.editor.dsl.scribbleDsl.Message
import org.scribble.editor.dsl.scribbleDsl.LocalInterruptible
import org.scribble.editor.dsl.scribbleDsl.LocalThrow
import org.scribble.editor.dsl.scribbleDsl.LocalCatch

/**
 * Provides labels for a EObjects.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#labelProvider
 */
class ScribbleDslLabelProvider extends org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider {

	@Inject
	new(org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}

	def text(Module elem) {
		'Module: ' + elem.name;
	}
	
	def text(PayloadTypeDecl elem) {
		'Type: ' + elem.getAlias();
	}
	
	def text(GlobalProtocolDecl elem) {
		'Global Protocol: ' + elem.getName();
	}
	
	def text(GlobalProtocolBlock elem) {
		'Sequence';
	}
	
	def text(GlobalMessageTransfer elem) {
		var String message=null;
		
		if (elem.getMessage().getParameter() != null) {
			message = 'Parameter[' + elem.getMessage().getParameter() + ']';
		} else if (elem.getMessage().getSignature() != null) {
			message = elem.getMessage().getSignature().getOperator();
		}
		
		message + ': ' + elem.getFromRole() + ' -> ' + elem.getToRoles();
	}
	
	def text(GlobalChoice elem) {
		'Choice: at ' + elem.getRole();
	}
	
	def text(GlobalParallel elem) {
		'Parallel';
	}
	
	def text(GlobalRecursion elem) {
		'Recursion: ' + elem.getLabel();
	}
	
	def text(GlobalContinue elem) {
		'Continue: ' + elem.getLabel();
	}
	
	def text(GlobalDo elem) {
		'Do';
	}
	
	def text(GlobalInterruptible elem) {
		'Interruptible';
	}
	
	def text(GlobalInterrupt elem) {
		var String messages="";
		
		for (Message mesg : elem.getMessages()) {
			if (mesg.getParameter() != null) {
				messages = messages + 'Parameter[' + mesg.getParameter() + ']';
			} else if (mesg.getSignature() != null) {
				messages = messages + mesg.getSignature().getOperator();
			}
		}
		
		'Interrupt: ' + messages + ' by ' + elem.getRole();
	}
	
	def text(LocalProtocolDecl elem) {
		'Local Protocol: ' + elem.getName() + ' @ ' + elem.getRole();
	}
	
	def text(LocalProtocolBlock elem) {
		'Sequence';
	}
	
	def text(LocalSend elem) {
		var String message=null;
		
		if (elem.getMessage().getParameter() != null) {
			message = 'Parameter[' + elem.getMessage().getParameter() + ']';
		} else if (elem.getMessage().getSignature() != null) {
			message = elem.getMessage().getSignature().getOperator();
		}
		
		message + ': to ' + elem.getToRoles();
	}
	
	def text(LocalReceive elem) {
		var String message=null;
		
		if (elem.getMessage().getParameter() != null) {
			message = 'Parameter[' + elem.getMessage().getParameter() + ']';
		} else if (elem.getMessage().getSignature() != null) {
			message = elem.getMessage().getSignature().getOperator();
		}
		
		message + ': from ' + elem.getFromRole();
	}
	
	def text(LocalChoice elem) {
		'Choice: at ' + elem.getRole();
	}
	
	def text(LocalParallel elem) {
		'Parallel';
	}
	
	def text(LocalRecursion elem) {
		'Recursion: ' + elem.getLabel();
	}
	
	def text(LocalContinue elem) {
		'Continue: ' + elem.getLabel();
	}
	
	def text(LocalDo elem) {
		'Do';
	}
	
	def text(LocalInterruptible elem) {
		'Interruptible';
	}
	
	def text(LocalThrow elem) {
		var String messages="";
		
		for (Message mesg : elem.getMessages()) {
			if (mesg.getParameter() != null) {
				messages = messages + 'Parameter[' + mesg.getParameter() + ']';
			} else if (mesg.getSignature() != null) {
				messages = messages + mesg.getSignature().getOperator();
			}
		}
		
		'Throw: ' + messages + ' to ' + elem.getToRoles();
	}
	
	def text(LocalCatch elem) {
		var String messages="";
		
		for (Message mesg : elem.getMessages()) {
			if (mesg.getParameter() != null) {
				messages = messages + 'Parameter[' + mesg.getParameter() + ']';
			} else if (mesg.getSignature() != null) {
				messages = messages + mesg.getSignature().getOperator();
			}
		}
		
		'Catch: ' + messages + ' from ' + elem.getFromRole();
	}
	
	// Labels and icons can be computed like this:
	
//	def text(Greeting ele) {
//		'A greeting to ' + ele.name
//	}
//
//	def image(Greeting ele) {
//		'Greeting.gif'
//	}
}
